package com.lupcode.Utilities.pools;

import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import com.lupcode.Utilities.exceptions.ObjectPoolCapacityException;

/** Manages multiple {@link ByteBuffer} for efficient memory usage
 * @author LupCode.com (Luca Vogels)
 * @since 2020-02-11
 */
public class ByteBufferPool extends AbstractObjectPool<ByteBuffer> {
	
	protected int buffer_size;
	protected Lock lock = new ReentrantLock();
	protected HashMap<Integer, Long> buffers = new HashMap<>();
	protected Queue<ByteBuffer> free_buffers = new LinkedList<>();
	protected AtomicLong current_total_size = new AtomicLong();

	public ByteBufferPool(int buffer_size, long max_total_size, int min_keep_count, long keep_unused_alive, ObjectPoolFullMode full_mode) {
		super(max_total_size, min_keep_count, keep_unused_alive, full_mode);
		this.buffer_size = buffer_size;
	}
	
	/**
	 * @return size in bytes for the capacity per {@link ByteBuffer}
	 */
	public int getBufferSize(){
		return buffer_size;
	}
	
	/** Sets the size in bytes for the capacity per {@link ByteBuffer}. 
	 * Also clears this {@link ByteBufferPool} if new buffer size is smaller than previous one
	 * @param buffer_size size in bytes
	 */
	public void setBufferSize(int buffer_size){
		boolean need_update = this.buffer_size < buffer_size;
		this.buffer_size = buffer_size;
		if(need_update)
			clear();
	}
	
	@Override
	public long getCurrentTotalSize(){
		return this.current_total_size.get();
	}
	
	@Override
	public int getFreeCount(){
		return free_buffers.size();
	}
	
	@Override
	public int getTotalCount(){
		return buffers.size();
	}
	
	@Override
	public void clear(){
		lock.lock();
		buffers.clear();
		free_buffers.clear();
		current_total_size.set(0);
		lock.unlock();
	}
	
	@Override
	public boolean isFull(){
		return this.max_total_size > 0 && this.current_total_size.get() + buffer_size > this.max_total_size;
	}
	
	@Override
	public ByteBuffer allocateFreeObject() throws ObjectPoolCapacityException {
		lock.lock();
		if(isFull() && free_buffers.isEmpty()){
			switch (full_mode) {
			case RETURN_NULL: lock.unlock(); return null;
			case THROW_EXCEPTION: lock.unlock(); throw new ObjectPoolCapacityException();
			default: break;
			}
		}
		ByteBuffer buffer = null;
		do {
			
			buffer = free_buffers.poll();
			if(buffer!=null){ buffer.clear(); break; }
			
			if(!isFull()){
				this.current_total_size.addAndGet(this.buffer_size);
				buffer = ByteBuffer.allocate(buffer_size);
				break;
			}
			
			lock.unlock();
			waiting.incrementAndGet();
			synchronized (this) {
				try { wait(); } catch (InterruptedException e) { e.printStackTrace(); }
			}
			lock.lock();
			waiting.decrementAndGet();
			
		} while(buffer==null);

		buffers.put(System.identityHashCode(buffer), System.currentTimeMillis());
		lock.unlock();
		return buffer;
	}

	@Override
	public void releaseObject(ByteBuffer buffer) {
		if(buffer!=null){
			lock.lock();
			final int buffer_key = System.identityHashCode(buffer);
			Long previous = buffers.put(buffer_key, System.currentTimeMillis());
			if(previous!=null)
				free_buffers.add(buffer);
			else
				buffers.remove(buffer_key); // object wasn't generated by this reuser
			lock.unlock();
		}
		clearUnused();
	}
	
	@Override
	public void clearUnused(){
		// notify waiting threads
		synchronized (this) {
			notifyAll();
		}
		
		if(this.keep_unused_alive<0){ return;} 
		
		// clean unused buffers
		lock.lock();
		final long current_time = System.currentTimeMillis();
		ByteBuffer buffer;
		int buffer_key;
		while(!free_buffers.isEmpty() && buffers.size() > min_keep_count){
			buffer = free_buffers.peek();
			buffer_key = System.identityHashCode(buffer);
			if(current_time - buffers.get(buffer_key) >= this.keep_unused_alive){
				free_buffers.poll();
				buffers.remove(buffer_key);
				this.current_total_size.addAndGet(-buffer.capacity());
			} else { break; }
		}
		lock.unlock();
	}
}
